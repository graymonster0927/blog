---
title: 收发包整个流程(epoll)
date: 2022-07-4
categories: [笔记, '网络', '零碎']
tags: [网络]
---

# 收发包整个流程(epoll)

## 收包

> 首先网卡驱动申请一个著名的数据结构sk_buffer，根据数据包中的网络类型type = skb->protocol(L3层 ipv4 or ipv6 ..)，去调用提前注册在内核中的ipv4 or ipv6 ..协议处理函数，比如调用ip_rcv()<br>
> 然后进一步解包，比如根据目的MAC地址和目的IP地址确定是否转发包，然后从包中解出是TCP or UDP，同样调用内核中注册好的回调函数处理，<br>
> 然后根据网络包的信息(hash一下，怎么hash看源码:) )对接上收包之前sys_recvfrom()建立的sock,最后进一步唤醒等待收包的进程。

* 数据帧到达网卡
* 网卡把帧DMA到内存
* 硬中断通知CPU (这里可以调整多少个包才硬中断)
* CPU响应硬中断, 简单处理后发出软中断 (这里可以调整绑定处理响应的cpu核数)(也可以调整多少个包才出发软中断)
* ksoftirqd进程处理软中断,那软中断是怎么处理网络包的呢？它会从 Ring Buffer 中拷贝数据到内核 struct sk_buff 缓冲区中，从而可以作为一个网络包交给网络协议栈进行逐层处理。
* 调用网卡驱动注册的poll函数开始收包
* 首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。
* 到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。
* 传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓冲区。
* 最后，应用层程序调用 Socket 接口，从内核的 Socket 接收缓冲区读取新到来的数据到应用层(唤醒执行ep_poll_callback)。
  * 用户调用该函数在执行后会将用户进行陷入到内核态
  * 从sk_receive_queue中拿数据 复制到用户态
  * 用户处理
    * epoll_wait -> 等待唤醒等待队列 -> 唤醒 -> 把事件组成列表返回给用户空间->用户处理


> 我们就能明确知道Linux收一个包的CPU开销了。 <br>
> 首先第一块是用户进程调用系统调用陷入内核态的开销。第二块是CPU响应包的硬中断的CPU开销。第三块是ksoftirqd内核线程的软中断上下文花费的。

### 触发 epoll
* 时机一 协议栈中，在三次握手完成之后，会往全连接队列中添加一个TCB结点，然后触发一个回调函数，通知到epoll里面有个EPOLLIN事件。
* 时机二 客户端发送一个数据包，协议栈接收后回复ACK，之后触发一个回调函数，通知到epoll里面有个EPOLLIN事件。
* 时机三 每个连接的TCB里面都有一个sendbuf，在对端接收到数据并返回ACK以后，sendbuf就可以将这部分确认接收的数据清空，此时sendbuf里面就有剩余空间，此时触发一个回调函数，通知到epoll里面有个EPOLLOUT事件。
* 时机四 当对端发送close，在接收到fin后回复ACK，此时会调用回调函数，通知到epoll有个EPOLLIN事件。
* 时机五 当接收到rst标志位的时候，回复ack之后也会触发回调函数，通知epoll有一个EPOLLERR事件。


## 发包
* 首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，Socket 层会将应用层数据拷贝到 Socket 发送缓冲区中。
* 接下来，网络协议栈从 Socket 发送缓冲区中取出数据包，并按照 TCP/IP 协议栈从上到下逐层处理。
* 如果使用的是 TCP 传输协议发送数据，那么会在传输层增加 TCP 包头，然后交给网络层，网络层会给数据包增加 IP 包，然后通过查询路由表确认下一跳的 IP，并按照 MTU 大小进行分片。
* 分片后的网络包，就会被送到网络接口层，在这里会通过 ARP 协议获得下一跳的 MAC 地址，然后增加帧头和帧尾，放到发包队列中。
* 这一些准备好后，会触发软中断告诉网卡驱动程序，这里有新的网络包需要发送，最后驱动程序通过 DMA，从发包队列中读取网络包，将其放入到硬件网卡的队列中，随后物理网卡再将它发送出去。

## see more
* [一定要看这个阿](https://blog.csdn.net/m0_37904728/article/details/134868771)
* [图解 Linux 网络包接收过程](https://www.ithome.com/0/645/789.htm)
* [你不好奇 Linux 网络发包过程吗？](https://xie.infoq.cn/article/6ba14b756c3019cc737ed48a6)
* [探讨一下共享内存通信中的通知机制](https://www.jianshu.com/p/d139b738bbe3)
* [源码解读epoll内核机制](http://gityuan.com/2019/01/06/linux-epoll/)
* [tcp三次握手源码解析](https://zhuanlan.zhihu.com/p/60744000)
* [epoll内核原理极简图文解读](https://zhuanlan.zhihu.com/p/454021287)
