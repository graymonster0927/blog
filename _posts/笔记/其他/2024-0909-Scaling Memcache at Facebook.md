---
title: Scaling Memcache at Facebook
date: 2024-08-9
categories: [笔记, 无主题零碎]
tags: [翻译]
---

# Scaling Memcache at Facebook (原文缩减翻译)

> Rajesh Nishtala, Hans Fugal, Steven Grimm, Marc Kwiatkowski, Herman Lee, Harry C. Li,
Ryan McElroy, Mike Paleczny, Daniel Peek, Paul Saab, David Stafford, Tony Tung,
Venkateshwaran Venkataramani
{rajeshn,hans}@fb.com, {sgrimm, marc}@facebook.com, {herman, hcli, rm, mpal, dpeek, ps, dstaff, ttung, veeve}@fb.com
Facebook Inc.

摘要： Memcached是一种众所周知的、简单的内存缓存解决方案。本文描述了Facebook如何利用memcached作为构建块来构建和扩展支持世界上最大社交网络的分布式键值存储。我们的系统每秒处理数十亿个请求，并容纳数万亿个项目，为全球超过10亿用户提供丰富的体验。

## 1简介

受欢迎和吸引人的社交网站带来了重大的基础设施挑战。数以亿计的人每天都在使用这些网络，并强加了传统网络架构难以满足的计算、网络和I/O需求。社交网络的基础设施需要（1）允许近实时通信，（2）实时聚合来自多个来源的内容，（3）能够访问和更新非常流行的共享内容，以及（4）扩展到每秒处理数百万个用户请求。

我们描述了我们如何改进memcached[14]的开源版本，并将其作为构建块，为世界上最大的社交网络构建分布式键值存储。我们讨论了从单个服务器集群扩展到多个地理分布集群的过程。据我们所知，该系统是世界上最大的memcached安装，每秒处理超过10亿个请求，存储数万亿个项目。

这篇论文是一系列工作中的最新一篇，这些工作已经认识到分布式键值存储的灵活性和实用性[1，2，5，6，12，14，34，36]。本文的重点是memcached——内存哈希表的开源实现，因为它以低成本提供了对共享存储池的低延迟访问。这些特性使我们能够构建数据密集型功能，否则这些功能将是不切实际的。例如，每个页面请求发出数百个数据库查询的功能可能永远不会离开原型阶段，因为它太慢，成本太高。然而，在我们的应用程序中，网页通常从memcached服务器中获取数千个键值对。

我们的目标之一是提出在我们部署的不同规模出现的重要主题。虽然性能、效率、容错和一致性等品质在所有规模上都很重要，但我们的经验表明，在特定规模下，某些品质需要比其他品质付出更多的努力。例如，与较大集群相比，在小集群上维护数据一致性会更容易。此外，随着服务器数量的增加, 当网络成为瓶颈，找到最佳通信时机的重要性也随之增加。

本文包括四个主要贡献：（1）我们描述了Facebook基于内存缓存的架构的演变。（2） 我们确定了对memcached的增强，这些增强可以提高性能和内存效率。（3） 我们强调了提高我们大规模运营系统能力的机制。（4） 我们描述了强加在系统上的生产工作负载。


## 2概述

以下特性对我们的设计有很大影响。

首先，用户消费的内容比他们创建的内容多一个数量级。这种行为导致了工作负载以读数据为主，并表明缓存可能具有显著的优势。其次，我们的读取操作从各种来源获取数据，如MySQL数据库、HDFS安装和后端服务。这种异构性就需要有一种灵活的缓存策略，能够存储来自不同来源的数据。 
Memcached提供的一组简单的操作（set、get和delete），使其具有优势作为大规模分布式系统中的基本组件。 我们开始使用的开源版本提供了一个单机内存哈希表。下面我们讨论如何采用这个单机内存哈希表作为开始，使用它来构建一个每秒可以处理数十亿个请求的更高效的分布式键值存储。

> 注意:我们使用“memcached”来指代源代码或运行的二进制文件，使用“memcache”来描述分布式系统。

![img.png](/commons/其他/image/img.png)

> 图1:Memcache作为缓存。左图说明缓存未命中时web服务器的读取路径。右图说明写入路径。

查询缓存：如图1所示。当web服务器需要数据时，它首先通过字符串键从memcache请求值。如果由该键寻址的项没有被缓存，web服务器从数据库或其他后端服务检索数据，并用键值对填充缓存。对于写入请求，web服务器会向数据库发出SQL语句，然后向memcache发送一个删除请求，使任何过时的数据无效。我们选择删除缓存的数据而不是更新它，因为删除是幂等的。Memcache不是数据的权威来源，因此允许收回缓存的数据。虽然有几种方法可以解决MySQL数据库上过多的读取流量，但我们选择使用memcache。考虑到有限的工程资源和时间，这是最好的选择。此外，将缓存层与持久层分离可以使我们在工作负载变化时独立调整每一层。
通用缓存：我们还利用memcache作为更通用的键值存储。例如，工程师们使用memcache来存储复杂的机器学习算法的预先计算结果，然后这些算法可以被各种其他应用程序使用。新服务利用现有的marcher基础架构几乎不需要付出什么努力，而无需调整、优化、资源调配和维护大型服务器组。

原生memcached不提供服务器到服务器的协调；它是在单个服务器上运行的内存中的哈希表。在本文的其余部分中，我们描述了我们如何构建一个基于memcached的分布式键值存储，该存储能够在Facebook的工作量我们的系统为或提供一套配置、聚合和路由服务

![img.png](/commons/其他/image/img1.png)

下面是三种不同部署规模。当我们有一个服务器集群时，我们的繁重工作负载和广泛的扇出是主要关注的问题。由于有必要扩展到多个前端集群，我们解决了这些集群之间的数据复制问题。最后，我们描述了在世界各地传播集群时提供一致用户体验的机制。操作复杂性和容错在所有规模上都很重要。我们提供了支持我们设计决策的重要数据，并请读者参考Atikogluet等人的工作。[8]对我们的工作量进行了更详细的分析。在高层，图2说明了这个最终的架构，在该架构中，我们将位于同一位置的集群组织到一个区域中，并指定一个主区域，该主区域提供数据流以使非主区域保持最新。

在设计我们的系统时，我们优先考虑两个主要的设计目标。（1）优化需要让用户操作感到有很大提升, 收益太小的优化是不必要的（2）为了避免后端存储服务负载过大, 过期数据也是允许被短暂读取到的

### 3 响应和负载

现在我们来思考在一个集群内把服务器扩容到上千台的挑战, 在扩容时, 我们主要关注这两点, 1.减少获取缓存数据的耗时 2.减少缓存读不到时后端存储服务的压力

#### 3.1 减少耗时

无论一个请求是否命中换成, memcache 响应的耗时都是影响请求耗时的重要原因, 通常在一个用户请求中, 会对 memcache 请求上百次, 举个例子, 一个加载推荐页的请求会在后端请求 521 次 memcache

我们提供一个上百 memcached组成的集群以减少数据库和服务的负载.数据按一致性哈希算法被分配在memcached中[22],  
