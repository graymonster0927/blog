---
title: 5.Go GC指南
date: 2023-05-20
categories: [笔记, golang, 包+翻译]
tags: [golang, 翻译]
---


# Go 垃圾回收 指南

## 目录
* [简介](#简介)
* [Go变量分配在哪里](#Go变量分配在哪里)
* [跟踪式垃圾回收](#跟踪式垃圾回收)
* [垃圾回收的生命周期](#垃圾回收的生命周期)
* [理解成本](#理解成本)
* [GOGC](#GOGC)
* [内存限制](#内存限制)
* [建议用法](#建议用法)
* [延迟](#延迟)
* [优化指南](#优化指南)
* [消除堆分配](#消除堆分配)
* [优化](#优化)

### 简介

这份指南是为了帮助高级GO用户通过更深的了解Go垃圾回收, 从而能更好的理解应用程序的相关开销. 同时用户也可以从这方面出发, 去提高自己应用程序的资源利用率<br>
本文不要求有垃圾回收相关的知识储备, 但需要熟悉go.<br>
go接管了值存储的管理, 大多数情况下, go 开发者不需要关心这些值是如何存储/为什么这样存储的, 实际上, 变量是需要被存储在物理内存中的, 同时物理内存资源是有限的, <br>
也正是因为内存的有限, 所以需要内存管理和回收, 从而避免在运行go程序时, 内存耗尽. 因此,go需要实现按需分配和回收内存的机制.<br>

自动回收内存的另一个术语是垃圾回收。在高层次上，垃圾回收器（或简称GC）是一种系统，它代表应用程序识别哪些内存部分不再需要并回收内存。Go标准工具链提供了一个运行时库，该库随每个应用程序一起提供，并且包括一个垃圾回收器。

请注意，此指南所描述的垃圾收集器的存在并不受Go规范的保证，仅保证Go变量的底层存储由语言本身管理。这种省略是有意的，并且使得可以使用根本不同的内存管理技术。

因此，本指南涉及Go编程语言的特定实现，可能不适用于其他实现。具体而言，本指南适用于标准工具链（即gc Go编译器和工具）。Gccgo和Gollvm都使用非常类似的GC实现，因此许多相同的概念适用，但细节可能会有所不同。<br>
另外，这是一个动态文档，会随着 go 版本的更新而更新。本文档当前描述了Go1.19的垃圾收集器。<br>

### Go变量分配在哪里
在我们深入研究 GC 之前, 我们先来讨论下不需要被 GC 管理的内存.<br>
<br>
Go在词法解析时确定应该在哪里给这个变量分配内存, 比如, local作用域的非指针Go变量很可能不会被Go GC管理, 一般来说，栈分配比依赖GC的内存分配更有效，因为Go编译器能够预先确定何时可以释放内存并发出清理的机器指令, 也就是说不需要GC。
通常，我们将Go变量的内存分配称为“stack allocation”(栈分配)，因为存储在goroutine stack(协程栈)上。<br>
<br>
对Go编译器无法确定其生存期，因此无法以这种方式分配内存的Go变量, 我们说这个变量"escape to the heap(逃逸到堆)"。
这种情况下, 我们一般在heap(堆)上给这个 Go 变量分配内存。在堆上分配内存的行为通常被称为“dynamic memory allocation(动态内存分配)”，因为对堆内存, 编译时和运行时都很难对如何使用内存以及何时清理内存做出假设。
那么GC的作用也就来了：它是一个专门识别和清理dynamic memory allocation(动态内存分配)的系统。<br>
<br>
在 Go 中，所有的变量都有可能被分配在栈或堆上，这取决于变量的生命周期和使用方式。当一个变量被确定要分配到堆上时，它的内存空间将被动态分配，并且需要进行垃圾回收。<br>
有很多原因会导致 Go 变量被分配到堆上, 变量的大小是动态的是其中一个原因. 比如一个初始 size 是变量的slice 切片(make([]int, 0, len(otherSlice)))<br>
再比如, Go变量被分配到堆上这一行为是能被传递的：如果一个变量的地址被写入另一个已确定要分配到堆上的变量中，那么它也必须分配到堆上。
这是因为如果这个变量分配在栈上，那么在另一个变量被分配到堆上之后，它所指向的内存空间可能已经被释放或重用，导致访问错误或数据损坏。因此，为了保证程序的正确性和稳定性，这个变量也必须被分配到堆上，以确保其生命周期和可用性与其他已经分配到堆上的变量一致。<br>
需要注意的是，这种情况只会在变量的地址被写入另一个已确定要分配到堆上的变量中时才会发生。如果变量的地址只是传递给一个函数或者存储在一个栈上的变量中，它仍然有可能被分配在栈上。<br>
决定Go变量是否逃逸到堆是根据它的上下文和Go编译器的逃逸分析算法函数。因为算法本身相当复杂，在不同Go版本之间也会发生变化,因此尝试精确定义哪些变量会分配在堆上是脆弱且困难的。<br>
<br>
有关如何识别哪些变量会分配到堆上，哪些不会，请参阅避免堆分配的章节。<br>

### 跟踪式垃圾回收

垃圾回收可以指许多不同的自动内存回收方法，例如引用计数。在本文档的上下文中，垃圾回收指的是跟踪式垃圾回收，它通过追踪指针来识别正在使用的对象，即所谓的活对象。<br>

让我们更加严格地定义这些术语：<br>

对象——一个对象是动态分配的一段内存，其中包含一个或多个 Go 变量。<br>

指针——一个内存地址，引用对象内的任何值。这自然包括 *T 形式的 Go 值，但也包括内置的 Go 值的部分。字符串、切片、通道、映射和接口值都包含 GC 必须跟踪的内存地址。<br>

对象和指向其他对象的指针共同形成对象图。为了识别活内存，GC 从程序的根开始遍历对象图，这些根是明确正在被程序使用的对象的指针。局部变量和全局变量是两个根的例子。遍历对象图的过程被称为扫描。<br>

这个基本算法对于所有跟踪式 GC 都是共通的。跟踪式 GC 的差别在于它们发现内存是活动的后会做什么。Go 的 GC 使用标记-清除技术，这意味着为了跟踪其进展，GC 还会将其遇到的值标记为活动的。一旦扫描完成，GC 就会遍历堆中的所有内存，将所有未被标记的内存释放以供分配。这个过程被称为清除。<br>

你可能熟悉的一种替代技术是将对象实际移动到内存的新部分，并留下一个转发指针，稍后用于更新所有应用程序的指针。我们将以这种方式移动对象的 GC 称为移动式 GC；Go 使用的是非移动式 GC。<br>

### 垃圾回收的生命周期

因为Go的GC是标记清除式垃圾回收机制，因此它主要分为两个阶段：标记阶段和清除阶段。虽然这个说法可能听起来很平凡，但它包含了一个重要的见解：在所有内存被跟踪之前，释放内存以供重新分配是不可能的，因为仍可能有未被扫描的指针保持对象存活。因此，清除操作必须完全与标记操作分离。此外，在没有与GC相关的工作需要处理时，GC也可能完全处于非活动状态。GC会不断地在清除、关闭和标记三个阶段之间循环，这被称为GC循环。在本文档中，将GC循环从清除开始，然后关闭，最后进行标记。<br>

接下来的几节将专注于建立GC成本的直觉，以帮助用户调整GC参数以达到自己的目的。<br>

### 理解成本
GC本质上是一个建立在更为复杂系统之上的复杂软件。当我们尝试理解GC并调整其行为时，很容易陷入细节中。本节旨在提供一个框架，帮助人们思考Go GC的成本并调整参数。<br>

首先，考虑基于三个简单公理的GC成本模型。<br>

GC只涉及两种资源：CPU时间和物理内存。<br>

GC的内存成本包括实际堆内存、标记阶段前分配的新堆内存以及元数据的空间。即使与前面的成本成比例，元数据也相对较小。<br>

注：实际堆内存是由上一个GC周期确定为实时的内存，而新堆内存是当前周期中分配的任何内存，可能到最后是实时的，也可能不是。<br>

GC的CPU成本被建模为每个周期的固定成本和随实际堆大小成比例的边际成本。<br>

应用程序的对象图每次看起来都大致相同（对象大小相似，指针数量大致相同，图的最大深度大致相同）。<br>

另一种思考这个问题的方式是，GC的边际成本是恒定的。<br>

> 注：稳态可能看起来有点牵强，但它代表了在某个恒定工作负载下应用程序的行为。自然地，即使应用程序正在执行，工作负载也可能会改变，但通常应用程序的行为看起来像一堆这样的稳态连在一起，其中夹杂着一些瞬态行为。

> 注：稳态不对活堆做任何假设。它可能随着每个后续的GC周期而增长，可能缩小，也可能保持不变。然而，试图在下面的解释中涵盖所有这些情况很麻烦，也不太具有说明性，因此本指南将重点介绍活堆保持恒定的情况。在GOGC部分，我们将更详细地探讨非恒定活堆的情况。

在稳态下，当活堆大小保持恒定时，只要GC在相同的时间段后执行，每个GC周期在成本模型中看起来都是相同的。这是因为在固定的时间段内，随着应用程序的固定分配速率，将分配固定量的新堆内存。因此，当活堆大小恒定且新堆内存恒定时，内存使用始终是相同的。并且因为活堆的大小相同，边际GC CPU成本也将是相同的，并且固定成本将在某个固定间隔内发生。<br>

现在考虑如果GC将运行时间点推迟。然后，将分配更多的内存，但每个GC周期仍然会产生相同的CPU成本。但是，在某个固定的时间窗口内，将完成较少的GC周期，从而导致较低的总CPU成本。如果GC决定更早地开始，则情况相反：将分配更少的内存，并且CPU成本将更加频繁地发生。<br>

这种情况代表了GC可以进行的CPU时间和内存之间的根本权衡，由GC实际执行的频率控制。换句话说，这个权衡完全由GC频率定义。<br>

还有一个细节需要定义，那就是GC何时应该决定开始。请注意，这直接设置了在任何特定的稳态中GC频率，从而定义了权衡。在Go中，决定GC何时应该开始是用户可以控制的主要参数。<br>


### GOGC

在高层次上，GOGC决定了垃圾回收CPU和内存之间的权衡。<br>

它通过确定每个GC周期后的目标堆大小来工作，即下一个周期中总堆大小的目标值。 GC的目标是在总堆大小超过目标堆大小之前完成收集周期。总堆大小定义为前一个周期结束时的活动堆大小加上自上一个周期以来应用程序分配的任何新堆内存。同时，目标堆内存定义为：<br>

目标堆内存 = 活动堆 + (活动堆 + GC根) * GOGC / 100 <br>
Target heap memory = Live heap + (Live heap + GC roots) * GOGC / 100 <br>

例如，考虑一个Go程序，具有8 MiB的活动堆大小，1 MiB的goroutine堆栈和1 MiB的全局变量指针。然后，使用GOGC值为100，下一次GC运行之前将分配的新内存量将是10 MiB，或者10 MiB工作量的100％，总堆占用空间为18 MiB。如果GOGC值为50，则为50％，即5 MiB。如果GOGC值为200，则为200％，即20 MiB。<br>

注意：自Go 1.18起，GOGC仅包括根集。以前，它只计算活动堆。虽然goroutine堆栈中的内存量通常非常小，GC的工作量主要根据活动堆大小决定，但在程序具有数十万个goroutine的情况下，GC做出了不好的决策。<br>

> 在Go语言中，goroutine的栈是从堆中分配的，而不是从操作系统的栈空间中分配。<br>
> 在操作系统中，每个线程都有一个固定大小的栈，这个栈通常在程序启动时就被预先分配了，因此在程序运行过程中无法扩展。然而，Go语言中的goroutine栈是可以根据需要动态地扩展和收缩的。<br>
> 为了实现这种动态扩展，Go语言使用了一种称为“分段栈”的技术，即将goroutine的栈划分为多个固定大小的段，并在需要时动态地分配和释放这些段。这些段是从堆中分配的，因此可以根据需要动态地扩展和收缩。<br>

总的来说，goroutine的栈是从堆中分配的，而不是从操作系统的栈空间中分配。这种设计使得Go语言可以高效地管理大量的goroutine，而不必担心栈空间的限制。

堆目标控制GC频率：目标越大，GC开始另一个标记阶段的时间越长，反之亦然。虽然精确的公式有助于进行估计，但最好根据其基本目的来考虑GOGC：选择GC CPU和内存之间的点的参数。关键要点是，将GOGC加倍将使堆内存开销加倍，并大致将GC CPU成本减半，反之亦然。（要查看完整的说明，请参见附录。）<br>

注意：目标堆大小仅是一个目标，GC周期可能不会恰好在该目标处结束。例如，足够大的堆分配可能会超过目标。但是，在超出本指南迄今为止使用的GC模型的GC实现中，可能会出现其他原因。有关更多详细信息，请参见延迟部分，但完整的细节可能在附加资源中找到。<br>

可以通过GOGC环境变量（所有Go程序都识别）或通过runtime/debug包中的SetGCPercent API配置GOGC。<br>

请注意，通过将GOGC设置为off或调用SetGCPercent（-1），也可以使用GOGC完全关闭GC（前提是不应用内存限制）。概念上，此设置相当于将GOGC设置为无限<br>




请注意，垃圾回收总是会带来一些 CPU 和峰值内存开销。随着 GOGC 的增加，CPU 开销减少，但峰值内存会与活跃堆大小成比例地增加。随着 GOGC 的降低，峰值内存需求会减少，但额外的 CPU 开销也会增加。<br>

注意：图表显示的是 CPU 时间，而不是程序完成的墙钟时间。如果程序在单个 CPU 上运行并完全利用其资源，则它们是等效的。实际的程序可能在多核系统上运行，并且不会始终 100% 利用 CPU。在这些情况下，垃圾回收对墙钟时间的影响会较低。<br>

注意：Go 垃圾回收器的最小总堆大小为 4 MiB，因此如果 GOGC 设置的目标小于该值，则会向上取整。可视化反映了这个细节。<br>

这是另一个更加动态和真实的示例。一次应用程序在没有 GC 的情况下需要 10 秒的 CPU 时间才能完成，但是稳态分配速率在一半时显著增加，而且在第一阶段中活跃堆大小会有一些变化。该示例演示了当活跃堆大小实际变化时稳态可能看起来的样子，以及更高的分配速率会导致更频繁的 GC 周期。<br>

### 内存限制

在Go 1.19之前，GOGC是唯一可以用于修改垃圾收集器行为的参数。虽然它在设置折衷方面效果很好，但它没有考虑可用内存是有限的。考虑一下当活跃堆大小出现短暂峰值时会发生什么：由于垃圾收集器将选择与该活跃堆大小成比例的总堆大小，因此必须为峰值活跃堆大小配置GOGC值，即使在通常情况下，更高的GOGC值提供更好的折衷方案。 <br>

如果示例工作负载在可用内存略高于60 MiB的容器中运行，那么即使其余的垃圾回收周期可以利用额外的内存，GOGC也不能增加到100以上。此外，在某些应用程序中，这些短暂的峰值可能很少并且难以预测，导致偶尔出现不可避免且潜在昂贵的内存不足情况。 <br>

这就是为什么在1.19版本中，Go添加了对设置运行时内存限制的支持。内存限制可以通过所有Go程序识别的GOMEMLIMIT环境变量或通过运行时/debug包中提供的SetMemoryLimit函数进行配置。 <br>

此内存限制设置了Go运行时可使用的总内存量上限。具体包括的内存集由runtime.MemStats表达式定义，如下所示： <br>

* Sys - HeapReleased <br>

* or equivalently in terms of the runtime/metrics package, <br>
 
* /memory/classes/total:bytes - /memory/classes/heap/released:bytes <br>

由于Go的垃圾收集器能够显式控制其使用的堆内存量，因此它基于此内存限制以及Go运行时使用的其他内存量来设置总堆大小。 <br>

请注意，当内存限制低于由GOGC确定的峰值内存时（对于GOGC为100，为42 MiB），垃圾回收会更频繁地运行，以使峰值内存保持在限制范围内。 <br>

回到我们之前关于短暂堆峰值的示例，通过设置内存限制和增加GOGC，我们可以兼顾两者：没有内存限制违规，同时获得更好的资源经济性。尝试下面的交互式可视化。 <br>

需要注意的是，当内存限制降低到接近 GOGC 决定的峰值内存大小时，GC 会更频繁地运行，以保持峰值内存在限制范围内。

回到之前的暂时堆峰值的例子，通过设置内存限制并增加 GOGC，我们可以得到最佳的解决方案：没有内存限制违规，同时也获得了更好的资源经济效益。可以试着使用下面的交互式可视化工具。

需要注意的是，当某些 GOGC 和内存限制的值时，峰值内存使用将停留在内存限制处，但程序的其余部分的执行仍然遵循 GOGC 设定的总堆大小规则。

这个观察结果引出了另一个有趣的细节：即使 GOGC 被关闭，内存限制仍然被遵守！实际上，这种特定的配置代表了资源经济效益的最大化，因为它设置了维持某些内存限制所需的最小 GC 频率。在这种情况下，程序的整个执行过程都会使堆大小上升到满足内存限制。

然而，虽然内存限制是一个强大的工具，但它的使用也不是没有代价的，并且并不能使 GOGC 失效。

考虑当实时堆增长到足以使总内存使用接近内存限制时会发生什么。在上面的稳态可视化工具中，试着关闭 GOGC，然后慢慢降低内存限制，看看会发生什么。请注意，当 GC 不断运行以维护不可能的内存限制时，应用程序所需的总时间将开始无限制地增长。

这种情况，即程序由于不断进行 GC 循环而无法合理地进展，被称为抖动（thrashing）。它特别危险，因为它实际上使程序停滞。更糟糕的是，它可能会因为我们试图通过 GOGC 避免的情况而发生：足够大的暂时堆峰值可能会导致程序无限期停滞！在暂时堆峰值的可视化工具中尝试降低内存限制（大约为 30 MiB 或更低），并注意最坏的情况特别是从堆峰值开始。

在许多情况下，无限期的停顿比内存不足更糟糕，后者往往会导致更快的故障。

因此，内存限制被定义为软限制。Go运行时不能保证在所有情况下都能维持这个内存限制，它只承诺会尽最大努力。这种对内存限制的放宽对于避免Thrashing行为至关重要，因为它给了垃圾回收器一种避免过度GC的方法：让内存使用超过限制，以避免在GC上花费太多时间。

内部实现是，垃圾回收器在某个时间窗口内设置了一个CPU时间的上限（对于非常短暂的CPU使用波动，有一些滞后调整）。该限制目前设置为大约50％，带有2 * GOMAXPROCS CPU秒的时间窗口。限制GC CPU时间的后果是，GC的工作被延迟，与此同时，Go程序可能会继续分配新的堆内存，甚至超过内存限制。

50％的GC CPU限制的直觉基于在有充足可用内存的情况下对程序最坏影响的考虑。在内存限制配置错误的情况下，即错误地将其设置得太低的情况下，程序最多会减速2倍，因为GC不能超过50％的CPU时间。


### 建议用法

虽然内存限制是一个强大的工具，Go运行时会采取措施来缓解误用带来的最严重影响，但仍然需要谨慎使用。以下是一些关于内存限制最适用和适用性较差的建议。

* 当Go程序的执行环境完全在您的控制范围内，且该Go程序是某些资源的唯一可访问程序（即某种内存预留，例如容器内存限制）时，请利用内存限制。 
  * 一个很好的例子是将Web服务部署到具有固定可用内存量的容器中。在这种情况下，一个经验法则是留出额外的5-10％的余量，以考虑Go运行时不知道的内存来源。

* 在适应变化的情况下，可以随时调整内存限制。
  * 一个很好的例子是一个cgo程序，其中C库可能会暂时需要使用更多的内存。

* 如果Go程序可能与其他程序共享其有限的内存，并且那些程序通常与Go程序解耦，请不要在内存限制下关闭GOGC。相反，保留内存限制可能有助于控制不希望出现的短暂行为，但对于平均情况，将GOGC设置为较小的合理值。
  * 虽然尝试为共享租户程序“预留”内存可能很诱人，但除非程序完全同步（例如，Go程序调用某个子进程并在其被调用者执行时阻塞），否则结果会不太可靠，因为两个程序都必须需要更多的内存。让Go程序在不需要时使用较少的内存会生成更可靠的结果。因此开启GOGC有助于此. 这个建议也适用于过度承诺的情况，其中在一个机器上运行的容器的内存限制总和可能超过机器实际可用的物理内存。

* 不要限制在无法预知内存使用量的应用的内存，特别是当程序的内存使用量与其输入成比例时。

* 一个很好的例子是CLI工具或桌面应用程序。将内存限制嵌入程序中时，如果不清楚可能会提供什么样的输入，或系统上可用多少内存，可能会导致令人困惑的崩溃和性能下降。此外，高级最终用户始终可以设置内存限制（如果他们愿意）。

* 当程序已经接近其环境的内存限制时，不要设置内存限制以避免内存不足条件。
  * 这实际上将内存不足的风险替换为应用程序严重减速的风险，即使Go采取了缓解抖动的措施，这通常也不是一个有利的交换。在这种情况下，要么增加环境的内存限制（然后可能设置内存限制），要么减少GOGC（这提供比抖动缓解更清晰的权衡）将更有效。 

### 延迟

本文中的可视化模型假定应用程序在执行垃圾回收时处于暂停状态。确实存在这种行为的垃圾回收实现，被称为“停止-整个世界（stop-the-world）”的垃圾回收。

然而，Go语言的垃圾回收不是完全的停止-整个世界，并且大部分工作都是与应用程序并发执行的。这主要是为了减少应用程序的延迟。具体来说，是为了减少单个计算单位（例如Web请求）的端到端持续时间。迄今为止，本文主要考虑应用程序的吞吐量（例如每秒处理的Web请求数）。请注意，GC周期部分中的每个示例都专注于执行程序的总CPU持续时间。然而，对于例如Web服务这样的应用程序而言，这种持续时间远不如每个单独请求的延迟更重要。

因此，重要的结论是，减少GC频率也可能会导致延迟的改进。这不仅适用于通过修改调整参数（例如增加GOGC和/或内存限制）来减少GC频率，还适用于优化指南中描述的优化措施。

然而，理解延迟通常比理解吞吐量更加复杂，因为它是程序每时每刻的执行结果，而不仅仅是成本的聚合。因此，延迟和GC频率之间的关系较少直接。下面是一些可能导致延迟的来源，供那些想深入研究的人参考。

* 垃圾回收器在标记和清扫阶段之间转换时会出现短暂的停顿，
* 当GC处于标记阶段时，会占用25％的CPU资源，导致调度延迟， 
* 当出现高分配率时，用户goroutine会协助GC， 
* 指针写入在GC处于标记阶段时需要额外的工作， 
* 运行中的goroutine必须暂停，以便它们的根可以被扫描。

除了指针写入需要额外工作之外，这些延迟源在执行跟踪中都是可见的。

### 关于虚拟内存的说明

本指南主要关注GC对物理内存使用的影响，但经常有一个问题：这究竟是什么意思，它与虚拟内存（通常在程序中显示为“VSS”）有什么区别。

物理内存是大多数计算机实际物理RAM芯片中存储的内存。虚拟内存是操作系统提供的一个关于物理内存的抽象，用于将程序相互隔离。通常，程序可以保留虚拟地址空间，这些空间并不映射到任何物理地址。

由于虚拟内存只是由操作系统维护的映射，因此通常很容易创建大的虚拟内存保留，这些保留并不映射到物理内存。

Go运行时通常依赖于这种虚拟内存成本的观点：

* Go运行时从不删除映射的虚拟内存。相反，它使用大多数操作系统提供的特殊操作来显式释放与某些虚拟内存范围关联的任何物理内存资源。
* 这种技术被明确用于管理内存限制并将不再需要的内存返回给操作系统。Go运行时还会在后台持续释放不再需要的内存。有关更多信息，请参阅其他资源。
* 在32位平台上，Go运行时会预留128 MiB至512 MiB的地址空间用于堆，以限制碎片问题。

Go运行时在实现几个内部数据结构时使用大型虚拟内存地址空间保留。在64位平台上，它们通常具有大约700 MiB的最小虚拟内存占用量。在32位平台上，它们的占用量可以忽略不计。

因此，“VSS”等虚拟内存度量通常对于了解Go程序的内存占用不是非常有用。相反，应该关注“RSS”和类似的度量，这些度量更直接反映了物理内存使用情况。


### 优化指南

#### 识别成本
在尝试优化Go应用程序与GC的交互之前，首先需要确定GC本身是一个重要的成本。

Go生态系统提供了许多用于识别成本和优化Go应用程序的工具。有关这些工具的简要概述，请参阅诊断指南。在这里，我们将重点介绍这些工具的一个子集以及应用它们的合理顺序，以了解GC的影响和行为。

##### CPU Profile

开始的好地方是CPU Profile。CPU Profile提供了CPU时间花费的概述，虽然对于未经训练的人来说，可能很难确定GC在特定应用程序中所扮演的角色的重要性。幸运的是，了解GC的作用大多归结为知道runtime包中不同函数的含义。以下是解释CPU配置文件的这些函数的有用子集。

注意：下面列出的函数不是叶子函数，因此可能不会出现在pprof工具提供的默认顶部命令中。相反，请使用top -cum命令或直接在这些函数上使用list命令，并关注累积百分列。

* runtime.gcBgMarkWorker：专用标记工作协程的入口点。在这里花费的时间与GC频率、对象图的复杂性和大小成比例。它代表了应用程序标记和扫描所花费的时间的基准线。
注意：在大多数闲置的Go应用程序中，Go GC将使用额外的（空闲的）CPU资源来更快地完成工作。因此，这个符号可能代表了相当大比例的样本，认为它们是免费的。这种情况经常发生的一个原因是如果一个应用程序完全在一个goroutine中运行，但GOMAXPROCS>1。
* runtime.mallocgc：堆内存的内存分配器的入口点。在这里累计花费大量的时间（>15%）通常表示分配了大量的内存。
* runtime.gcAssistAlloc：函数goroutine进入以放弃部分时间来帮助GC扫描和标记。在这里花费的大量累计时间（>5%）表明应用程序可能比GC分配得更快。它表示GC的影响特别大，并且也代表应用程序花费在标记和扫描上的时间。请注意，这包含在runtime.mallocgc调用树中，因此它也会膨胀。

##### Execution Trace
虽然CPU Profile很适合识别在总体上花费时间的地方，但它们对于指示更微妙、更罕见或与延迟特别相关的性能成本不太有用。
另一方面，执行跟踪提供了一个深入的视角，展示了 Go 程序执行的短时间窗口。执行跟踪包含了与 Go 垃圾回收相关的各种事件，直接观察到了特定的执行路径，以及应用程序如何与 Go 垃圾回收交互。所有跟踪的 GC 事件在跟踪查看器中都有标记，非常方便。

可以看看 runtime/trace 包展示如何执行跟踪

##### GC Traces
当其他方法都失败时，Go GC 提供了几种不同的具体跟踪，可以提供更深入的 GC 行为洞察。这些跟踪总是直接打印到 STDERR，每个 GC 周期一行，并通过所有 Go 程序都识别的 GODEBUG 环境变量进行配置。它们大多对调试 Go GC 本身很有用，因为需要对 GC 实现的具体细节有一定的了解，但偶尔也可以用来更好地理解 GC 行为。

通过设置 GODEBUG=gctrace=1，可以启用核心 GC 跟踪。这个跟踪产生的输出在 runtime 包的文档中的环境变量部分有记录。

一种辅助的 GC 跟踪称为“pacer 跟踪”，提供了更深入的洞察，并通过设置 GODEBUG=gcpacertrace=1 启用。解释这个输出需要了解 GC 的“pacer”（参见其他资源），这超出了本指南的范围。


### 消除堆分配

减少垃圾回收（GC）管理的值的一种方法是从一开始就让 GC 管理更少的值。下面描述的技术可以产生最大的性能改进，因为正如 GOGC 部分所示，Go 程序的分配率是 GC 频率的一个主要因素，而 GC 频率是本指南使用的关键成本指标。

#### Heap profiling
在确定 GC 是主要成本来源后，消除堆分配的下一步是找出它们来自哪里。为此，内存分析（实际上是Heap profiling）非常有用。请查看文档以了解如何开始使用它们。

内存分析描述了堆分配在程序中来自哪里，通过在分配点的堆栈跟踪中进行识别。每个内存分析可以从四个方面对内存进行分解：

inuse_objects - 分解活动对象的数量。
inuse_space - 按字节分解活动对象使用的内存量。
alloc_objects - 分解自 Go 程序开始执行以来已分配的对象数量。
alloc_space - 分解自 Go 程序开始执行以来已分配的总内存量。
可以使用 pprof 工具的 -sample_index 标志或在交互使用工具时使用 sample_index 选项来在这些不同的堆内存视图之间切换。

注意：默认情况下，内存分析只采样堆对象的子集，因此它们不会包含有关每个单独的堆分配的信息。但是，这足以找到热点。要更改采样率，请参见 runtime.MemProfileRate。

对于降低 GC 成本的目的，alloc_space 通常是最有用的视图，因为它直接对应于分配速率。这个视图将指示分配热点，从而提供最大的效益。

#### 逃逸分析

通过堆分析找到了候选堆分配位置后，如何消除它们呢？关键在于利用 Go 编译器的逃逸分析，让 Go 编译器为该内存寻找替代的、更高效的存储方式，例如在 goroutine 栈中。幸运的是，Go 编译器有能力描述它为何决定将一个 Go 值逃逸到堆上。有了这些知识，就变成了重新组织源代码以改变分析结果的问题（这通常是最难的部分，但不在本指南的范围之内）。

至于如何访问 Go 编译器的逃逸分析信息，最简单的方法是通过 Go 编译器支持的调试标志，在文本格式中描述它所应用或未应用到某个包的所有优化。这包括值是否逃逸。尝试以下命令，其中 [package] 是某个 Go 包路径。

> $ go build -gcflags=-m=3 [package]

> 此信息也可以在 VS Code 中作为覆盖层进行可视化。可以通过配置 VS Code Go 插件设置来启用该覆盖层。
> 设置 ui.codelenses 以包括 gc_details。
> 通过将 ui.diagnostic.annotations 设置为包括 escape，启用逃逸分析的覆盖层。
> 最后，Go 编译器以机器可读的（JSON）格式提供这些信息，可以用于构建额外的自定义工具。有关更多信息，请参见源代码中的文档。


### 优化

Go的垃圾回收器(GC)对存活内存的特征非常敏感，因为对象和指针的复杂图形既限制并行性，又为GC生成更多工作。因此，GC包含一些针对特定常见结构的优化。下面列出了对性能优化最直接有用的优化。

注意：应用下面的优化可能会降低代码的可读性并掩盖意图，并且可能在不同的Go版本之间失效。建议仅在最需要的地方应用这些优化。可以使用成本识别部分中列出的工具来确定这些位置。

* 无指针的值与其他值分开存储。
因此，从不严格需要指针的数据结构中消除指针可能是有利的，因为这减少了GC对程序施加的缓存压力。因此，依赖于指针值的索引的数据结构，虽然类型不太好，但可能表现更好。只有在明显的对象图形复杂且GC花费大量时间进行标记和扫描时，才值得这样做。

* GC会在值中的最后一个指针处停止扫描。
因此，在struct类型的值中将指针字段分组在值的开头可能是有利的。只有在明显应用程序花费大量时间进行标记和扫描时，才值得这样做。(理论上，编译器可以自动执行此操作，但尚未实现，结构字段按源代码中编写的顺序排列。)

此外，GC必须与它看到的几乎每个指针交互，因此，例如使用索引而不是指针的切片可以帮助减少GC成本。

## 附录

### Go GC 额外指南

在GOGC 的那部分说，将GOGC翻倍会使堆内存开销翻倍并减半GC CPU成本。为了了解原因，让我们从数学上来解析。

首先，堆目标设置了总堆大小的目标。然而，这个目标主要影响新堆内存，因为活跃堆对应用程序是基本的。

> 目标堆内存=活跃堆+(活跃堆+GC根)*GOGC/100
> 总堆内存=活跃堆+新堆内存
> ⇒
> 新堆内存=(活跃堆+GC根)*GOGC/100

从这里我们可以看出，将GOGC翻倍也将使应用程序每个循环分配的新堆内存量翻倍，这捕捉了堆内存开销。请注意，活跃堆+GC根是GC需要扫描的内存量的近似值。

接下来，让我们看一下GC CPU成本。总成本可以分解为每个循环的成本，乘以某个时间段T内的GC频率。

> 总GC CPU成本=(每个循环的GC CPU成本)*(GC频率)*T

每个循环的GC CPU成本可以从GC模型中得出:

> 每个循环的GC CPU成本=(活跃堆+GC根)*(每字节成本)+固定成本

请注意，在这里忽略了清扫阶段的成本，因为标记和扫描成本占主导地位。

稳态由恒定的分配速率和恒定的每字节成本定义，因此在稳态下，我们可以从这个新的堆内存推导出GC频率:

> GC频率=(分配速率)/((活跃堆+GC根)*GOGC/100)

将这些结合起来，我们得到总成本的完整公式:

> 总GC CPU成本=(分配速率)/((活跃堆+GC根)GOGC/100)((活跃堆+GC根)*(每字节成本)+固定成本)*T

对于一个足够大的堆(这代表了大多数情况)，一个GC循环的边际成本主导了固定成本。这使得总GC CPU成本公式得到了显著的简化。

> 总GC CPU成本=(分配速率)/(GOGC/100)*(每字节成本)*T

从这个简化的公式中，我们可以看出，如果我们将GOGC翻倍，我们将减半总GC CPU成本。(请注意，本指南中的可视化模拟固定成本，因此它们报告的GC CPU开销在GOGC翻倍时不会完全减半。)此外，GC CPU成本在很大程度上由分配速率和扫描内存的每字节成本决定。有关如何特别减少这些成本的更多信息，请参见优化指南。

注：存在一种情况，即存活堆的大小与GC实际需要扫描的内存量之间存在差异：相同大小的存活堆但具有不同的结构将导致不同的CPU成本，但是相同的内存成本，导致不同的权衡。这就是为什么堆的结构是稳定状态定义的一部分。堆目标应该只包括可扫描的存活堆，作为更接近GC需要扫描的内存的近似值，但是当可扫描的存活堆非常小但存活堆本身很大时，这会导致退化行为。
