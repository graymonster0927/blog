---
title: 一个http请求的整个流程
date: 2022-06-8
categories: [笔记, '网络', '零碎']
tags: [网络]
---


# 一个http请求的整个流程
                                       (               TCP                   )  
浏览器 -> DNS解析 -> 路由 -> 网卡收包 -> (三次握手建立连接 -> 服务处理 -> 四次挥手 )-> 网卡发包 -> 浏览器解析<br>

## DNS解析

* 首先浏览器会检查自身缓存是否解析过这个域名的IP地址，如果有即缓存命中，那么解析结束；
* 如果浏览器缓存中没有，那么浏览器会检查操作系统缓存中是否有相应的解析过的结果。而操作系统也有一个域名解析的过程。像我们熟悉的hosts文件/浏览器缓存，如果用户在这里定义了一个域名对应的IP地址，那么浏览器会首先使用这里定义的IP地址；
* 如果此时还没有命中域名，才会真正地去请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不是很远，并且这台服务器的性能很好，一般这里会缓存域名解析的结果。大约80%的域名解析到这里就完成了；
* 如果LDNS仍然没有命中，那么LDNS就会向根域名服务器（Root Server）发起域名请求解析；
* 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com、.cn、.org等）地址；
* 此时LDNS再发送请求到上一步返回的gTLD的IP地址；
* 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器；
* Name Server根据映射关系表找到目标IP地址，并将其返回给LDNS；
* LDNS缓存这个域名和对应的IP；
* LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。

本地域名服务器(LDNS  比如软件服务商阿里云DNS等) -> 根域名服务器 -> 主域名服务器 -> 主域名服务器 -> 网站注册域名服务器
> dig +trace @8.8.8.8 www.baidu.com
[DNS解析过程详解](https://www.jianshu.com/p/38ac057179af)
[DNS架构](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd197427(v=ws.10)?redirectedfrom=MSDN)
## 路由

* （1）源主机在发起通信之前，将⾃⼰的IP地址与⽬的主机的IP地址进⾏⽐较，如果源主机判断⽬的主机与⾃⼰位于不同⽹段时，它需要通过⽹关来递交报⽂的，所以它⾸先需要通过⼀个ARP请求报⽂获取⽹关的MAC地址（在源主机不知道⽹关MAC地址的情形下, 可能在本机APR缓存中找到），即源主机先发送ARP请求帧以获取⽹关IP地址对应的MAC地址。  
* （2）⽹关在收到源主机发来的ARP请求报⽂后以⼀个ARP应答报⽂进⾏回应，在应答报⽂中的“源MAC地址”就包含了⽹关的MAC地址。
* （3）在得到⽹关的ARP应答后，源主机再⽤⽹关MAC地址作为报⽂的“⽬的MAC地址”，以源主机的IP地址作为报⽂的“源IP地址”，以⽬的主机的IP地址作为“⽬的IP地址”，先把发送给⽬的主机的数据发给⽹关。 
* （4）⽹关在收到源主机发送给⽬的主机的数据后，由于查看得知源主机和⽬的主机的IP地址不在同⼀⽹段，于是发到交换机
* （5）如果交换机没有找到⽬的主机的对应表项，则向CPU请求查看软件路由表，如果有⽬的主机所在⽹段的路由表项，则还需要得到⽬的主机的MAC地址，因为数据包在链路层是要经过帧封装的。于是交换机CPU向⽬的主机所在⽹段发送⼀个ARP⼴播请求包，以获得⽬的主机MAC地址。 
* （6）交换机获得⽬的主机MAC地址后，向ARP表中添加对应的表项，并转发由源主机到达⽬的主机的包。
*  中间可能会有负载均衡(四层/七层)

## 网卡收包
[收发包整个流程](/posts/收发包整个流程)

## TCP

### 三次握手
* 第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SENT状态，等待服务器确认；
* 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
* 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
* 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

> why三次握手 第一次syn包客户端能正常发包  第二次ack服务器能正常收包和发包 第三次syn+ack客户端能正常收包 

### 四次挥手

* 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
* 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
* 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
* 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

> why 四次挥手 [https://zhuanlan.zhihu.com/p/440129714]

### Http
一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组

## 网卡发包
[收发包整个流程](/posts/收发包整个流程)
