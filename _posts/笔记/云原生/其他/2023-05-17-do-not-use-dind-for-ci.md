---
title: don't use dind for ci
date: 2023-05-17
categories: [笔记, '云原生', 'k8s其他']
tags: [云原生, 翻译]
---

> 原文 : [do-not-use-dind-for-ci](https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)

Docker-in-Docker的主要目的是帮助开发Docker本身。许多人使用它来运行CI（例如使用Jenkins），一开始看起来似乎没问题，但他们会遇到许多“有趣”的问题，而通过将Docker套接字绑定到Jenkins容器中，可以避免这些问题。

让我们来看看这意味着什么。如果你只想要简短的解决方案而不需要细节，请直接滚动到本文底部。☺

更新（2020年7月）：当我在2015年写这篇博文时，运行Docker-in-Docker的唯一方法是在Docker中使用-privileged标志。如今，情况已经大不相同了。容器安全性和沙箱技术有了很大进步，例如使用无特权容器和诸如sysbox之类的工具。sysbox可以让您在没有-privileged标志的情况下运行Docker-in-Docker，并且甚至还针对一些特定场景进行了优化，例如将Kubernetes集群的多个节点作为普通容器运行。本文已经更新以反映这一点！

两年多前，我为Docker贡献了-privileged标志，并编写了dind的第一个版本。目标是帮助核心团队更快地进行Docker开发。在引入Docker-in-Docker之前，典型的开发周期是：

```
修改代码
构建
停止当前运行的Docker守护进程
运行新的Docker守护进程
测试
重复上述步骤
如果您想进行一个良好、可复制的构建（即在一个容器中），则过程会更加复杂：

修改代码
确保正在运行一个可用的Docker版本
使用旧的Docker构建新的Docker
停止Docker守护进程
运行新的Docker守护进程
测试
停止新的Docker守护进程
重复上述步骤
有了Docker-in-Docker的出现，这个过程简化为：

修改代码
一步完成构建和运行
重复上述步骤
```

是不是好多了呢？
##### 不好的
然而，与普遍的观点相反，Docker-in-Docker并不完全是闪闪发光、小马和独角兽。我的意思是，有一些问题需要注意。

其中之一是与AppArmor和SELinux等Linux安全模块（LSM）相关的问题：当启动一个容器时，“内部Docker”可能会尝试应用安全配置文件，这些配置文件可能会与“外部Docker”发生冲突或混淆。实际上，当尝试合并-privileged标志的原始实现时，这是最难解决的问题。我的更改在我的Debian机器和Ubuntu测试虚拟机上运行正常（通过了所有测试），但在Michael Crosby的机器上（如果我没记错的话，他的机器是Fedora），会出现崩溃和错误。我记不清具体问题的原因，但可能是因为Mike是一个明智的人，他在运行时将SELINUX=enforce（而我使用的是AppArmor），而我的更改没有考虑到SELinux配置文件。

##### 丑陋的
第二个问题与存储驱动程序有关。当您在Docker中运行Docker时，外部Docker运行在正常的文件系统上（EXT4、BTRFS等），但内部Docker运行在写时复制系统上（AUFS、BTRFS、Device Mapper等，取决于外部Docker的设置）。存在许多无法正常工作的组合。例如，您不能在AUFS上运行AUFS。如果在BTRFS上运行BTRFS，一开始可能会正常工作，但一旦有嵌套的子卷，删除父卷将失败。Device Mapper没有进行命名空间隔离，因此如果同一台机器上有多个Docker实例使用它，它们将能够看到（并影响）彼此的镜像和容器后备设备。这并不理想。

针对这些问题有一些解决方法；例如，如果您想在内部Docker中使用AUFS，只需将/var/lib/docker提升为一个卷，问题就会得到解决。Docker为Device Mapper目标名称添加了一些基本的命名空间，这样，如果同一台机器上运行多个Docker实例，它们不会相互干扰。

然而，正如您可以从GitHub上dind存储库中的这些问题中看到的那样，设置并不完全简单明了。

##### 甚至更糟糕

关于构建缓存，当使用Docker-in-Docker时，确实可能变得相当棘手。人们经常问我：“我正在运行Docker-in-Docker，如何使用主机上的镜像，而不是在内部Docker中重新拉取所有内容？”

一些冒险的人尝试将主机上的/var/lib/docker通过绑定挂载方式挂载到Docker-in-Docker容器中。有时他们会与多个容器共享/var/lib/docker目录。

这种方法在某些情况下可能会起作用，但是它存在一些问题。首先，由于涉及到容器和宿主机之间的文件系统交互，可能会引起权限和安全性问题。其次，当多个容器共享/var/lib/docker目录时，可能会导致冲突和竞争条件。

为了更可靠地管理构建缓存，可以考虑使用一些其他的方法。一种常见的做法是在Docker-in-Docker容器中设置一个本地的镜像缓存代理，例如配置一个私有的Docker镜像仓库或使用第三方的镜像缓存工具。

总结起来，尽管有人尝试通过绑定挂载方式在Docker-in-Docker容器中使用主机上的镜像，但这种方法可能会引起权限和冲突问题。更可靠的方式是考虑使用其他方法来管理构建缓存，如设置本地镜像缓存代理。

Docker守护进程被明确设计为对/var/lib/docker具有独占访问权限。其他任何东西都不应该接触、操作或修改那里隐藏的Docker文件。

为什么这样设计呢？这是从dotCloud时代吸取的宝贵教训之一。dotCloud容器引擎通过让多个进程同时访问/var/lib/dotcloud来工作。聪明的技巧，如原子文件替换（而不是原地编辑）、在代码中加入咨询和强制锁定，以及对SQLite和BDB等安全性较高的系统进行其他实验，只能让我们走得更远；当我们重构我们的容器引擎（最终成为Docker）时，其中一个重要的设计决策是将所有容器操作集中在一个单一的守护进程下，摆脱所有这些并发访问的麻烦。

（别误会：完全有可能通过涉及多个进程和最新的并发管理技术来实现高效、可靠和快速的操作；但我们认为，选择Docker的单一执行者模型更简单，更易于编写和维护。）

这意味着如果您在多个Docker实例之间共享/var/lib/docker目录，那么您将会遇到问题。当然，它可能在早期测试阶段能够工作。“看吧，我可以运行docker run ubuntu！”但试着进行更复杂的操作（从两个不同的实例拉取相同的镜像...）然后看着世界崩溃。

这意味着如果您的CI系统进行构建和重建，每次重新启动Docker-in-Docker容器时，可能会清除其缓存。这真的不太好。

##### 进步

您肯定听说过马克·吐温（Mark Twain）那句著名的名言的某个变体：“他们不知道这是不可能的，所以他们做到了。”

许多人尝试过安全地运行Docker-in-Docker。几年前，我在用户命名空间和一些非常恶心的黑客技巧上取得了一些成功（包括在tmpfs挂载上模拟cgroups伪文件系统结构，以便容器运行时不会抱怨太多；那是有趣的时光），但似乎找到一个干净的解决方案将是一个重大的任务。

现在存在一个干净的解决方案：它被称为sysbox。Sysbox是一个OCI运行时，可以替代或与runc一起使用。它使得可以在不使用特权标志的情况下运行通常需要特权标志的“系统容器”，并为这些容器之间以及容器与主机之间提供足够的隔离。

Sysbox还提供了优化以运行容器内的容器。具体而言，在并行运行多个Docker实例时，可以使用共享的镜像集“种子”它们。这既节省了大量的磁盘空间，也节省了大量的时间，我认为这在运行例如容器中的Kubernetes节点时会产生巨大的差异。

（在CI/CD中运行容器中的Kubernetes节点可能特别有用，当您想要部署Kubernetes的分段应用程序或在其自己的集群中运行测试时，而不需要部署专用机器上的完整集群的基础设施成本和时间开销。）

长话短说：如果您的使用案例确实绝对需要Docker-in-Docker，请看看sysbox，它可能是您所需要的解决方案。

##### socket 方案

让我们先停下来思考一下。您真的想要Docker-in-Docker吗？还是只是想要能够在CI系统中运行Docker（具体来说：构建、运行，有时还有推送容器和镜像），而这个CI系统本身就在一个容器中？

我敢打赌，大多数人都想要后者。您只是想要一个解决方案，以便您的CI系统（如Jenkins）可以启动容器。

最简单的方法就是通过使用-v标志将Docker套接字绑定挂载到您的CI容器中，从而使其暴露给CI容器。

简单来说，当您启动CI容器（Jenkins或其他容器）时，不要使用Docker-in-Docker来拼凑一些东西，而是使用以下命令启动：

docker run -v /var/run/docker.sock:/var/run/docker.sock ...
现在，这个容器将具有对Docker套接字的访问权限，因此将能够启动容器。但是，它将启动“兄弟”容器，而不是“子”容器。

试一试，使用docker官方镜像（其中包含Docker二进制文件）：

docker run -v /var/run/docker.sock:/var/run/docker.sock
-ti docker
这看起来像Docker-in-Docker，感觉像Docker-in-Docker，但它并不是真正的Docker-in-Docker：当此容器创建更多容器时，这些容器将在顶级Docker中创建。您将不会遇到嵌套副作用，并且构建缓存将在多个调用之间共享。

⚠️此前的版本建议将主机上的docker二进制文件与容器进行绑定挂载。但由于Docker引擎不再作为（几乎）静态库分发，这种方法现在不再可靠。

如果您想要在Jenkins CI系统中使用Docker，有多种选择：

使用基础映像的软件包管理系统（例如，如果您的映像基于Debian，请使用.deb软件包）安装Docker CLI，
使用Docker API。
